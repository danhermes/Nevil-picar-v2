{
  "project": "NEVIL",
  "description": "Nevil PiCar v2 Project Tasks",
  "issues": [
    {
      "id": "NEVIL-1",
      "name": "Missing System Monitor",
      "type": "Bug",
      "summary": "system_monitor executable not found in libexec directory",
      "description": "The ROS2 launch system is unable to find the system_monitor executable in the expected location: '/home/dan/nevil/src/install/nevil_bringup/lib/nevil_bringup'.\n\n**Root Cause Analysis:**\n- The system_monitor.py script exists in the source directory (~/nevil/src/nevil_bringup/scripts/system_monitor.py)\n- However, it's not being installed to the lib directory during the build process\n- Only nevil_cli.py is being installed, despite the CMakeLists.txt file specifying both scripts\n\n**Current Workaround:**\n- Modified the launch file to use ExecuteProcess instead of Node\n- This bypasses the need for the executable to be in the lib directory\n- Directly runs the Python script from its source location\n\n**Pros of ExecuteProcess Approach:**\n- Simplicity: Directly executes the script without installation requirements\n- Flexibility: Can run scripts from any location, not just installed locations\n- Development Friendly: Easier to test changes without rebuilding/reinstalling\n- No Build Dependencies: Works regardless of build system configuration\n- Quick Fix: Immediate solution without modifying build files\n\n**Cons of ExecuteProcess Approach:**\n- Non-Standard: Doesn't follow ROS2 best practices\n- Limited Lifecycle Management: Doesn't integrate with ROS2 node lifecycle\n- Manual Parameter Handling: Parameters must be passed as command-line arguments\n- Namespace Issues: May require manual namespace configuration\n- Resource Management: Less controlled termination and cleanup\n\n**Permanent Solution Options:**\n1. Fix the build system to properly install system_monitor.py to the lib directory\n2. Create a proper entry point in setup.py for the system_monitor script",
      "priority": "High",
      "status": "To Do",
      "assignee": null,
      "reporter": "Dan",
      "created": "2025-06-08T07:52:00+01:00",
      "updated": "2025-06-08T07:52:00+01:00",
      "components": ["nevil_bringup", "build_system"],
      "labels": ["bug", "launch-file", "executable-path"],
      "fixVersions": ["2.1.0"],
      "links": []
    },
    {
      "id": "NEVIL-2",
      "name": "Fix CMakeLists",
      "type": "Task",
      "summary": "Update CMakeLists.txt to properly install system_monitor.py",
      "description": "Update the CMakeLists.txt file in the nevil_bringup package to ensure that system_monitor.py is properly installed to the lib directory. This is a permanent solution to NEVIL-1.",
      "priority": "Medium",
      "status": "To Do",
      "assignee": null,
      "reporter": "Dan",
      "created": "2025-06-08T07:52:00+01:00",
      "updated": "2025-06-08T07:52:00+01:00",
      "components": ["nevil_bringup", "build_system"],
      "labels": ["build", "cmake"],
      "fixVersions": ["2.1.0"],
      "links": [{"type": "relates to", "issue": "NEVIL-1"}]
    },
    {
      "id": "NEVIL-3",
      "name": "Setup.py Entry Point",
      "type": "Task",
      "summary": "Create proper entry point in setup.py for system_monitor",
      "description": "Update the setup.py file in the nevil_bringup package to create a proper entry point for the system_monitor script. This is an alternative permanent solution to NEVIL-1.",
      "priority": "Medium",
      "status": "To Do",
      "assignee": null,
      "reporter": "Dan",
      "created": "2025-06-08T07:52:00+01:00",
      "updated": "2025-06-08T07:52:00+01:00",
      "components": ["nevil_bringup", "build_system"],
      "labels": ["build", "python"],
      "fixVersions": ["2.1.0"],
      "links": [{"type": "relates to", "issue": "NEVIL-1"}]
    },
    {
      "id": "NEVIL-4",
      "name": "Document Workaround",
      "type": "Task",
      "summary": "Document ExecuteProcess workaround in launch file",
      "description": "Add comments to the full_system.launch.py file explaining why ExecuteProcess is used instead of Node for the system_monitor script. This will help future developers understand the workaround.",
      "priority": "Low",
      "status": "To Do",
      "assignee": null,
      "reporter": "Dan",
      "created": "2025-06-08T07:52:00+01:00",
      "updated": "2025-06-08T07:52:00+01:00",
      "components": ["nevil_bringup", "documentation"],
      "labels": ["documentation", "launch-file"],
      "fixVersions": ["2.0.1"],
      "links": [{"type": "relates to", "issue": "NEVIL-1"}]
    },
    {
      "id": "NEVIL-5",
      "name": "Missing Hardware Interface",
      "type": "Bug",
      "summary": "Implement RTHardwareInterface to control physical robot",
      "description": "The documentation describes a hardware abstraction layer that allows the system to control the physical PiCar-X robot, but the actual implementation is missing. The rt_motor_control_node.py file contains a comment: \"In a real implementation, this would use the RTHardwareInterface with proper mutex handling\", but this interface is not implemented.\n\n**Impact:**\n- The system cannot control the physical robot despite documentation claiming this functionality\n- The Picarx class and robot_hat library are available but not integrated into the codebase\n- Core functionality described in the architecture documentation is not implemented\n\n**Required Implementation:**\n1. Create RTHardwareInterface class that interfaces with the robot_hat library\n2. Implement methods for motor control, servo control, and sensor reading\n3. Integrate with the existing hardware abstraction layer\n4. Update the rt_motor_control_node.py to use the RTHardwareInterface\n5. Test with the physical PiCar-X robot",
      "priority": "Critical",
      "status": "Done",
      "assignee": "AI Assistant",
      "reporter": "Dan",
      "created": "2025-06-08T08:33:00+01:00",
      "updated": "2025-06-08T08:38:00+01:00",
      "resolution": "Implemented RTHardwareInterface class that interfaces with the Picarx class and robot_hat library. The implementation includes thread-safe methods for motor control, steering, distance sensing, and camera control with proper mutex handling. Updated rt_motor_control_node.py to use this interface and added an entry point in setup.py for testing the hardware interface.",
      "components": ["nevil_realtime", "hardware_interface"],
      "labels": ["bug", "hardware", "critical-functionality"],
      "fixVersions": ["2.0.0"],
      "links": []
    }
  ]
}